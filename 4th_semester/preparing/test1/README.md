## Подготовка к первой контрольной:
<b> [v1_1](./v1_1.cpp): </b><br>

    Опишите функцию set_min, которая принимает два параметра - переменные типа int, определяет,
    в какой из двух переменных значение меньше, и заносит это значение в обе переменные.
    Вызов функции будет выполняться с указанием в качестве параметров имён переменных без каких-либо
    дополнительных операций (взятия адреса и т.п.)

<br> <b> [v1_2](./v1_2.cpp): </b><br>

    Опишите класс Flag, объект которого может находиться в одном из двух состояний - 
    «взведён» (оп) и «сброшен» (off). Предусмотрите методы SetOn и SetOff, устанавливающие флаг
    в соответствующее положение, а также метод IsOn, возвращающий логическое значение (истина, если объект
    находится в состоянии «взведён», ложь в противном случае), который должен
     допускать работу для константных объектов.

<br> <b> [v1_3](./v1_3.cpp): </b><br>
    
    Модифицируйте класс Flag из предыдущей задачи так, чтобы его объекты (без явного применения к ним каких-либо
    дополнительных операций) можно было использовать в качестве логического значения (условного
    выражения), например, в операторах if, while и т.п. Это должно работать в том числе и для константных объектов. 

<br> <b> [v1_4](./v1_4.cpp): </b><br>
    
    Опишите класс Watched, допускающий создание объекта без указания параметров. Реализуйте в этом классе
    метод Amount так, чтобы вызвать его можно было без объекта, указав имя класса. Метод Amount должен возвращать
    целое число, соответствующее количеству существующих в настояший момент объектов класса Counted. 
    Не забудьте про случай создания объекта как копии другого объекта!

<br> <b> [v1_5](./v1_5.cpp): </b><br>
    
    Опишите классы A и В так, чтобы (при условии, что a и b - объекты соответственно А и класса В):
    • Выражения вида a[b] и b[a] были равны числу 75 (здесь и далее подразумеваются числа типа int);
    • Выражение а() было равно числу 50, выражение a(b) было равно числу 100, выражение a(b, b)
    было равно числу 150, выражение b(a) было равно числу 200;
    • Выражение а(а,а,а) успешно проходило компиляцию в качестве целочисленного, во при попытке
    его вычислить выбрасывало исключение типа А;
    • Выражение --а было равно числу 500, выражение а-- - числу 501.

<br> <b> [v1_6](./v1_6.cpp): </b><br>
    
    Опишите класс D и (при необходимости) дополнительные классы или структуры так, чтобы (при условии,
    что d есть объект класса D) выражение d->1 представляло собой целочисленную переменную, которой можно
    присваивать значения, которая сохраняет присвоенное значение и из которой это значение можно извлечь как
    из обычной переменной; в случае, если в программе описано больше одного объекта класса D,
    каждому такому объекту должна соответствовать своя собственная целочисленная переменная, доступная через
    операцию ->f. то есть такие переменные не должны конфликтовать. Объект класса D должен допускать
    создание без указания параметров. Любая динамическая память должна корректно освобождаться.

<br> <b> [v1_7](./v1_7.cpp): </b><br>
    
    Опишите класс IntQueue, представляющий понятие «очереди целых чисел", реализованный через односвязный
    список с указателями на начало и конец (возможности стандартной библиотеки С++ не использовать!).
    Предусмотрите операции <<= (левый операнд - объект вашего класса, правый - целочисленное выражение,
    операция добавляет элемент в конец очереди) и >>= (правый операнд - переменная типа int, 
    операция извлекает элемент из начала очереди; если нечего извлекать, бросьте исключение
    класса QueueEmpty, который опишите сами). Предусмотрите метод Amount, возвращающий текущее количество 
    элементов в очереди. 
    Вся выделенная динамическая память должна быть корректно освобождена - память от извлекаемых элементов
    освобождается при их извлечении, память от всего остального освобождается при уничтожении объекта очереди.

<br> <b> [v1_8](./v1_8.cpp): </b><br>
    
    Модифицируйте класс IntQueue из предыдущей задачи, снабдив его виртуальной функцией Check, принимающей параметр
    типа int и возвращающей логическое значение; функция должна допускать работу для константных объектов. В классе
    IntQueue функция Check должна всегда возвращать «истину», но предполагается, что классы-наследники могут
    заменить эту функцию своей версией таковой. При добавлении нового числа в очередь это число должно проверяться
    вызовом функции Check, и если функция вернула истину, число должно помещаться в очередь, в противном случае - 
    игнорироваться. Унаследуйте от класса IntQueue класс EvenFilter, принимающий для помещения в очередь только
    чётные числа. Этот класс должен отличаться от базового только функцией Check. Учтите, что в ходе тестирования
    от класса будут наследоваться также другие потомки.

<br> <b> [v2_1](./v2_1.cpp): </b><br>
    
    Опишите класс А, а в нём открытую функцию f с пустым списком параметров, возвращающую целое число и допускающую
    вызов без объекта, те с указанием имени класса. Функция при первом её вызове должна возвращать ноль, а при каждом
    следующем - число на единицу большее предыдущего.

<br> <b> [v2_2](./v2_2.cpp): </b><br>
    
    Опишите класс Functor таким образом, чтобы (при условии, что f - объект этого класса) выражение f(x,y)
    было равно сумме чисел x и y. Выражение должно работать в том числе и для константных объектов.

<br> <b> [v2_3](./v2_3.cpp): </b><br>
    
    Опишите класс PseudoArray, представляющий собой "псевдомассив" целых чисел. К объектам класса должна быть применима
    операция индексирования, аргумент которой, имеющий тип int, должен игнорироваться, то есть должно создаваться
    впечатление, что в массиве столько элементов, сколько существует различных значений int, причём все элементы
    равны одному и тому же числу. Начальное значение всех «элементов» - ноль. Изменение значения производится присваиванием,
    как для обычных массивов. Извлечение значения элементов должно работать в том числе для константных объектов.

<br> <b> [v2_4](./v2_4.cpp): </b><br>
    
    Опишите класс Smart и, при необходимости, дополнительные классы таким образом, чтобы (если s - объект класса Smart, 
    возможно константного типа, выражение t = s[х], где t - целочисленная переменая, а x - целочисленное выражение, заносило
    в t значение, превосходящее х на единицу, а выражение вида t = s[x][y] заносило в произведение чисел х и у.
<br> <b> [v3_1](./v3_1.cpp): </b><br>
    
    Создайте класс Assign (и, при необходимости, дополнительные классы) так, чтобы выражение вида а->f(x,у)
    (где а - объект класса присваивало целочисленной переменной х значение у, при этом присвоенное значение запоминалось
    в объекте и могло быть получено методом Get ().

<br> <b> [v3_2](./v3_2.cpp): </b><br>
    
    Модифицируйте класс Assign из предыдущей задачи так, чтобы присвоить таким способом новое значение можно было
    переменной любого типа, если только для неё в принципе существует операция присваивания (в том числе для переменных,
    тип которых запрещает копирование, но позволяет присваивание). В этой версии не нужно реализовывать
    запоминание значения и метод Get().

<br> <b> [v3_3](./v3_3.cpp): </b><br>
    
    Опишите класс М и (при необходимости) дополнительные классы или структуры так, чтобы (при условии, что m есть объект класса M)
    выражение m(m) представляло собой целочисленную переменную, которой можно присваивать значения, которая сохраняет
    присвоенное значение и из которой значение можно извлечь как из обычной переменной; в случае, если в программе описано
    больше одного объекта класса М, каждому такому объекту должна соответствовать своя собственная целочисленная переменная,
    доступная через операцию вида x(x). При этом выражение вида m(x), где x - объект того же класса, отличный от m, должно
    всегда возвращать ноль, а присваивание любого целочисленного значения такому выражению не должно ничего менять. Объект класса
    должен допускать создание без указания параметров. Помните, что компиляция с флагом -Wall не должна вызывать предупреждений!

<br> <b> [v3_4](./v3_4.cpp): </b><br>
    
    Опишите класс SumHold для хранения суммы целых чисел. Добавление числа к сумме должно производиться операцией <<, причём эта
    операция должна быть описана так, чтобы можно было записывать «цепочки» вроде sh << 20 << 30 << 40 << 50, где sh - объект
    класса SumHold; такая «цепочка» должна последовательно добавлять к сумме числа слева направо. Предусмотрите метод Get(),
    возвращающий текущее значение суммы для данного объекта. Можете считать, что разрядности типа int будет достаточно.

<br> <b> [v3_5](./v3_5.cpp): </b><br>
    
    Добавьте в класс SumHold из предыдущей задачи метод GetAll(), возвращающий сумму всех чисел, добавленных с момента старта
    программы во все объекты класса SumHold. При необходимости введите дополнительные поля и/или методы.