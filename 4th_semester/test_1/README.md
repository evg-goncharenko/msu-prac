## Test No. 1
    
<b> [v1_1](./v1_1.cpp): </b><br>

Опишите абстрактный класс `IntSeq`, хранящий некоторую последовательность целых чисел, в котором описаны чистая виртуальная функция и конструктор:

```
virtual int Distance() const;   // для вычисления некоторого расстояния
IntSeq(int *pSeq, int n);       // где pSeq – адрес начала последовательности, а n – ее длина
```

Конструктор должен сохранять копию заданной последовательности в динамической памяти. Нужно предусмотреть автоматическую очистку памяти при прекращении существования объекта.

Унаследуйте от `IntSeq` класс `OrderedSeq`, хранящей строго упорядоченную по возрастанию последовательность целых чисел (для хранения этой последовательности используется базовый класс, своих полей-данных класс `OrderedSeq` иметь не должен). При попытке задать неупорядоченную последовательность выбрасывайте исключение типа BadSeq (класс можно оставить пустым). Функцию `Distance()` определите как максимальный модуль разности между соседними элементами последовательности.

Введите в классе операцию сложения, которая из двух упорядоченных последовательностей, строит новую последовательность посредством конкатенации, то есть к первой последовательности присоединяет вторую. Если так построенная последовательность не будет упорядоченной, то выбрасывайте исключение класса `BadConcat`, в объекте которого должны содержаться левая и правая границы обеих последовательностей, которые не удалось конкатенировать.
В результате следующая функция main():

``` 
int main() {
    try {
        int a[] = {1, 2, 3};
        int b[] = {7, 9, 10, 13};
        int c[] = {5, 6};
        OrderedSeq sa(a, 3), sb(b, 4), sc(c, 2); 
        cout << (sa + sb).Distance() << ", " << (sc + sb).Distance() << ", " << (sa + sc + sb).Distance() << endl; 
        cout << (sb + sc) .Distance() << endl; 
    }
    catch (const BadConcat& bad) {
        cout << "Bad concatenation " << bad.GetLeft1() << ", " << bad.GetRight1() << " + " << bad.GetLeft2() << ", " << bad.GetRight2() << endl; 
    }
    catch (BadSeq) { 
        cout << "Bad sequence\n"; 
    }       
    return 0; 
}
```
должна откомпилироваться без ошибок и предупреждений, отработать и выдать:
```
4, 3, 3
Bad concatenation 7, 13 + 5, 6
```
Все поля должны быть в закрытой (private) части базового класса, открытыми и защищёнными могут быть только функции-члены. Использование директивы friend запрещено. 
Для инициализации объектов используются конструкторы. Никакие методы не должны изменять внутренние поля объектов, допускаются только функции, возвращающие значения полей (но не меняющие ничего). Вся занятая память должна быть освобождена.


<br> <b> [v1_2](./v1_2.cpp): </b><br>

Опишите класс `Cls` (и, при необходимости другие классы) так, чтобы вычисление выражения вида `x = c[N]` (где `c` – объект класса `Cls`, `x` – переменная типа int, `N` - выражение, приводимое к int) заносило в переменную   `х`  значение `N + 1`,  а вычисление выражения вида `с[N] >>= x`   заносило в переменную `х` значение `N * 2`.
<b>Пример:</b>

```
int main() {
    Cls c;
    int x, N = 5;
    x = c[N];
    cout << x << "\n"; // print 6
    c[N] >>= x;
    cout << x << '\n'; // print 10
    return 0;
}
```

<br> <b> [v2_1](./v2_1.cpp): </b><br>

Опишите абстрактный класс `IntPair`, представляющий пару чисел типа int, котором описаны чистая виртуальная функция и конструктор:
```
virtual  int  Measure() const;  // для вычисления некоторой меры
IntPair(int x, int y);
```
Унаследуйте от `IntPair` класс `IntRectangle`, задающий понятие прямоугольника с целочисленными сторонами, хранящимися в базовом классе (первое число – длина, второе - ширина), своих полей-данных класс `IntRectangle` иметь не должен. При попытке сконструировать прямоугольник с отрицательными сторонами, выбрасывайте исключение типа `BadRectangle` (класс можно оставить пустым). Функцию `Measure()` определите как площадь прямоугольника. 

Введите в классе операцию сложения, которая «склеивает» два прямоугольника: если у них одинаковая ширина – то склеиваем по длине, иначе, если одинаковая длина – то по ширине. Например, сложение прямоугольников 5х4 и 7х4 даст прямоугольник 12х4,  5х4 + 5х2 даст прямоугольник 5х6, 5х3 + 5х3 даст 10х3  Если прямоугольники не имеют двух подходящих сторон (например, 5х3 и 3x5 или 5х3 и 6х4), то выбрасывайте исключение класса `BadAdd`, в объекте которого должны содержаться стороны обоих прямоугольников, которые не удалось сложить. 
В результате следующая функция main():

```
int main() { 
    try {
        IntRectangle a(5, 4), b(7, 4), c(2, 1), d(2, 3);
        IntRectangle p, q;
        p = a + b;
        q = c + d;
        cout << (p+q).Measure() << endl;
        cout << (p+d).Measure() << endl; 
    }
    catch (const BadAdd &bad) {
        cout << "Bad add: (" << bad.GetX1() << " x " << bad.GetY1() << ") + (" << bad.GetX2() << " x " << bad.GetY2() << ")\n";  
    }
    catch (BadRectangle b) { 
        cout << "Bad rectangle\n"; 
    }       
    return 0; 
}
```
должна откомпилироваться без ошибок и предупреждений, отработать и выдать:
```
56
Bad add: (12 x 4) + (2 x 3)
```
Все поля должны быть в закрытой (private) части базового класса, открытыми и защищёнными могут быть только функции-члены. Использование директивы friend запрещено. 
Для инициализации объектов используются конструкторы. 
Никакие методы не должны изменять внутренние поля объектов, допускаются только функции, возвращающие значения полей (но не меняющие ничего).

<br> <b> [v2_2](./v2_2.cpp): </b><br>
    
Опишите класс `Assign` (и, при необходимости другие классы) так, чтобы вычисление выражения вида `a[x](y)` (где `a` – объект класса `Assign`, `x` – переменная типа int, y - выражение, приводимое к int) заносило в переменную   х  значение  y, при этом присвоенное значение запоминалось в объекте а и могло быть получено методом `Get()`.
<b>Пример:</b>

```
int main() {
    Assign a;
    int x = -1, y = 5;
    a[x](y);
    cout << a.Get() << endl; // print 5
    cout << x << endl;       // print 5
    return 0;
}
```
