\chapter{Реализация} \label{chapt4}
Для реализации был выбран язык \textbf{C++}, в силу своего быстродействия и удобства использования различных библиотек на языке C.

\section{Сборка проекта} \label{sect4_1}

\noindent Если проект собирается под Linux/MacOS и имеет все исходные файлы, включая rmu и bzip2, то достаточно просто запустить RunBuild. \\ Для других случаев ниже приведена подробная инструкция по сборке. \\

\noindent Для сборки проекта необходимо:
\begin{itemize}
  \item rmu (надо использовать новую версию, взаимодействие с которой происходит в кодировке utf-8); rmu требует bzip2, собиралось на версии 1.0.6.
  \item Библиотеки по умолчанию должны находится в rmu/Libs.
  \item Исходники (anz.cpp, anz.hpp, makefile).
  \item Makefile копирует собранный файл в переменную PATH, поэтому конечный файл libanalize.a находится в rmu/Libs.
\end{itemize}

\noindent Для работы библиотеки так же требуется файл prefix.dat в рабочей директории, который содержит информацию о префиксах.

\noindent Для успешной инициализации rmu требуются файлы вида rm.*.bin.data,причем бинарные файлы должны быть собраны версией rmu после рефакторинга под utf-8, если таких нет, их можно получить из json файлов (в кодировке utf-8) используя функцию int RMUEncode(const char * BaseName) расположенную в  RMUtilites, подробнее смотреть документацию RMU.

\section{Взаимодействие с библиотекой} \label{sect4_2}

\noindent Библиотека содержит только класс Word, взаимодействие с которым построено следующим образом:
\begin{itemize}
  \item Для начала необходимо создать экземпляр класса: \\
    Word word (''черно-белое'', ''rm'');
  \item После необходимо проанализировать слово: \\
    word.analize();
  \item Если word.error != true, то в word.result находится начальная форма слова, \\
  в word.stress - номер ударной буквы, а в word.RMUAnswer - исходное слово и вся информация о нем.
  \item Результатом работы программы будет: \\
    Result: черно-белый; \\
    Stressed letter: 8; \\
    Успешный результат работы RMU. 

\end{itemize}

\section{Описание класса Word} \label{sect4_3}

\begin{itemize}
  \item Конструктор: \\
    Word(const std::string word, const char* rm = "rm"); \\
    word - обязательное поле, слово которое необходимо проанализировать; \\
    rm – опциональный параметр, по умолчанию это рабочая директория, который указывает путь к базе данных вида rm.*.bin.data, собранных под utf-8 из кодировки utf-8.
  \item RMUAnswer: \\
    Содержит всю информацию об исходном слове, поле типа std::string.
  \item result: \\
    Простая форма слова, результат работы алгоритма, имеет тип std::string.
  \item stress: \\
    Номер ударной буквы в слове, типа int.
  \item error : \\
    Содержит bool значение, в случае если error = true, в процессе работы произошла ошибка и слово не может быть распознано.
  \item step1 – step7: \\
    Шаги в алгоритме соответсвенно.
  \item AnalyzeBefore: \\
    Префикс добавляемый в начале запроса к rmu.
  \item AnalyzeAfter: \\
    Постфикс добавляемый в конце запрооса к rmu.
  \item IRMUnit: \\
    Экземпляр RMU.
  \item X: \\
    Исходное слово.
  \item Х1: \\
    Префикс.
  \item Х2: \\
    Постфикс.
  \item Rec: \\
    Позволяет понять вызывался ли алгоритм рекурсивно до этого.
\end{itemize}

\clearpage