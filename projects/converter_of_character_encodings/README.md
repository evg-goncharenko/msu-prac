## Разработка программ-конвертеров кодировок UTF16-UTF8

Первая программа читает из канала ввода текст в кодировке UTF-16, переводит его в кодировку UTF-8 и выводит перекодированный текст в канал вывода ([converting_utf16_to_utf8.c](./converting_utf16_to_utf8.c)). Вторая программа читает из канала ввода текст в кодировке UTF-8, переводит его в кодировку UTF-16 и выводит перекодированный текст в канал вывода ([converting_utf8_to_utf16.c](./converting_utf8_to_utf16.c)). <br>
Если при запуске программы задан аргумент командной строки — имя файла, то вместо стандартного ввода текст берется из этого файла. Если задано два аргумента, то первый рассматривается как имя файла ввода, а второй — как имя файла вывода. Стандартные потоки ввода/вывода в этом случае не используются. В случае неправильного имени файла программа выдает сообщение об ошибке и завершается. <br>
Обе программы корректно обрабатывают маркер порядка байтов (byte order mark – BOM) – символ с кодом `0xFEFF` — в начале файла. Первая программа читает текст в UTF-16, а вторая программа — генерирует текст в UTF-16 в соответствии с прочитанным маркером. В случае отсутствия маркера принимается LE-порядок (то есть по умолчанию BOM представлен байтами `0xFF 0xFE` в начале файла). <br>
Также программы обрабатывают случаи некорректного представления входного текста — нечетное количество байтов в UTF-16, некорректные последовательности в UTF-8. В этих случаях программы  выдают в стандартный канал вывода сообщения об ошибках (stderr) диагностику, включающую в себя значение некорректного символа (последовательности), а также его смещение относительно начала файла. После этого программы «восстанавливаются» и продолжают чтение и перекодировку входной последовательности.

---

Для хранения UTF16-символов используется тип данных unsigned short, а для UTF-8 символов - char.

Двоичный образ файла (побайтно) можно посмотреть программой od (octal dump). `od le.utf`
покажет содержимое файла `le.utf` порциями по 2 байта в восьмеричном формате. Для вывода файла в 16-ичном формате побайтно используется следующий набор опций:
```
od -A x -t x1z -v le.utf
```
В восьмеричном формате байтов:
```
od -c le.utf
```
Если в системе установлена кодировка UTF-8 (что верно для многих установок), то файл в UTF-8 кодировке можно просто выдать на экран командой `cat имя_файла` или же просмотреть в любом текстовом редакторе.
Для того, чтобы просмотреть содержимое файла в любой кодировке, можно использовать редактор vim. После открытия файла командой `vim имя_файла` указывается кодировка файла командой:
```
:set fileencoding=ucs-2
```
Заметим, что кодировка ucs-2 использует прямой порядок байтов (big-endian). При чтении файла с обратным порядком байтов (little-endian) нужно использовать имя `ucs-2le`. Вместо `ucs-2` и `ucs-2le` можно использовать имена `utf-16` и `utf-16le`. Различия в этих кодировках не проявляются в тестовых файлах.

Команда `xxd` создаёт представление файла в виде шестнадцатеричных кодов или выполняет обратное преобразование. Пример использования:
```
xxd tmp.utf
```

Команда `hexedit` просмотривает и редактирует файлы в шестнадцатеричном формате или в формате ASCII. Пример использования:
```
hexedit tmp.utf
```

Команда `diff` ищет различия между двумя файлами. Флаг `-s` сообщает, что два файла являются одинаковыми. Пример использования:
```
diff ./tests/letext.ucs tmp.ucs -s
```

### Тестовые файлы

Для тестирования и отладки написан следующий (минимальный) набор файлов, который находится в каталоге `/tests`.

<b> UTF-16 файлы </b>

    - letext.ucs – текст в UTF-16 в перевернутом представлении (LE-порядок) с меткой BOM
    - betext.ucs – текст в UTF-16 в прямом представлении (BE-порядок) с меткой BOM
    - letextbad1.ucs – текст в UTF-16 в перевернутом представлении (LE-порядок) без
    метки BOM
    - betextbad1.ucs – текст в UTF-16 в прямом представлении (BE-порядок) без метки
    BOM
    - letextbad2.ucs – текст в UTF-16 в перевернутом представлении (LE-порядок) с меткой
    BOM, но с неверным символом (однобайтовым)
    - betextbad2.ucs – текст в UTF-16 в прямом представлении (BE-порядок) с меткой BOM,
    но с неверным символом (однобайтовым)
    - leempty.ucs – пустой текст в UTF-16 в перевернутом представлении (LE-порядок) с
    меткой BOM
    - beempty.ucs – пустой текст в UTF-16 в прямом представлении (BE-порядок) с меткой
    BOM
    - le30.ucs – односимвольный (код=0x30 – символ 0) текст в UTF-16 в перевернутом
    представлении (LE-порядок) с меткой BOM
    - be30.ucs – односимвольный (код=0x30 – символ 0) текст в UTF-16 в прямом
    представлении (BE-порядок) с меткой BOM
    - le42f.ucs – односимвольный (код=0x042F – символ Я) текст в UTF-16 в перевернутом
    представлении (LE-порядок) с меткой BOM
    - be42f.ucs – односимвольный (код=0x042F – символ Я) текст в UTF-16 в прямом
    представлении (BE-порядок) с меткой BOM
    - le263A.ucs – односимвольный (код=0x263A – символ ☺) текст в UTF-16 в
    перевернутом представлении (LE-порядок) с меткой BOM
    - be262A.ucs – односимвольный (код=0x263A – символ ☺ текст в UTF-16 в прямом
    представлении (BE-порядок) с меткой BOM

<b> UTF-8 файлы </b>

    - text.utf – текст в UTF-8 с меткой BOM (кодированной)
    - text2.utf – текст в UTF-8 без метки BOM
    - textbad1.utf – текст в UTF-8 с неверной последовательностью (начинается с байта
    продолжения) без метки BOM
    - textbad2.utf – текст в UTF-8 с неверной последовательностью (отсутствует байт
    продолжения) без метки BOM
    - empty.utf – пустой текст в UTF-8 с меткой BOM
    - 30.utf – односимвольный (код=0x30 – символ 0) текст в UTF-8
    - 42f.utf – односимвольный (код=0x042F – символ Я) текст в UTF-8
    - 263A.utf – односимвольный (код=0x263A – символ ☺) текст в UTF-8
