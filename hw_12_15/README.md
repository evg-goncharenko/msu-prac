## Домашнее задание на 15.12
<b> [task_1](./task_1.c): </b><br>
    
    В командной строке задано имя файла. Оставить в файле только те
    строки заданного файла, которые содержат хотя бы два одинаковых символа.
    Никакую дополнительную память для хранения строк и дополнительные файлы
    использовать нельзя. Для работы с файлом разрешено пользоваться
    только системными вызовами низкоуровневого ввода-вывода.
    Для «обрезки» файла до нужной длины использовать системные вызовы
    truncate() или ftruncate().
    
<br> <b> [task_2](./task_2.c): </b><br>

    Программа порождает дочерний процесс.
    Процесс-отец открывает файл (его имя задано в командной строке),
    в котором содержатся имена других файлов — по одному в строке,
    и через неименованный канал передает эти имена дочернему процессу.
    Дочерний процесс открывает полученный файл, печатает его имя,
    определяет длину файла, закрывает и результат передает отцу через ТОТ ЖЕ канал.
    Отец печатает длину соответствующего файла и перевод строки.
    Когда исходный файл заканчивается, отец закрывает канал и дожидается завершения
    дочернего процесса, а дочерний процесс, получив сигнал, печатает количество 
    обработанных файлов и завершается. Синхронизация процессов
    (при выводе в стандартный канал и работе с неименованным каналом)
    осуществляется с помощью сигналов.
    
<br> <b> [task_3](./task_3.c): </b><br>
    
    В программе процесс-отец порождает 3-х сыновей.
    В начальный момент все сыновья заблокированы с помощью
    системного вызова pause(). На каждое нажатие ctrl+C (SIGINT)
    отец по очереди в цикле разблокирует одного сына (другие в этот момент
    продолжают быть заблокированными). В активном состоянии каждый сын раз
    в секунду печатает свой PID. Через 10 секунд отец посылает всем сыновьям
    сигнал SIGKILL и сам завершается. Процессы «зомби» не остаются.

